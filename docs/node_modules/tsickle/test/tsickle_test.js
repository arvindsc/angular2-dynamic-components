"use strict";
var chai_1 = require('chai');
var fs = require('fs');
var path = require('path');
var ts = require('typescript');
var decorator_annotator_1 = require('../src/decorator-annotator');
var tsickle = require('../src/tsickle');
var util_1 = require('../src/util');
var testSupport = require('./test_support');
var RUN_TESTS_MATCHING = null;
// RUN_TESTS_MATCHING = /fields/;
// If true, update all the golden .js files to be whatever tsickle
// produces from the .ts source. Do not change this code but run as:
//     UPDATE_GOLDENS=y gulp test
var UPDATE_GOLDENS = !!process.env.UPDATE_GOLDENS;
/**
 * compareAgainstGoldens compares a test output against the content in a golden
 * path, updating the content of the golden when UPDATE_GOLDENS is true.
 *
 * @param output The expected output, where the empty string indicates
 *    the file is expected to exist and be empty, while null indicates
 *    the file is expected to not exist.  (This subtlety is used for
 *    externs files, where the majority of tests are not expected to
 *    produce one.)
 */
function compareAgainstGolden(output, path) {
    var golden = null;
    try {
        golden = fs.readFileSync(path, 'utf-8');
    }
    catch (e) {
        if (e.code === 'ENOENT' && (UPDATE_GOLDENS || output === null)) {
        }
        else {
            throw e;
        }
    }
    if (UPDATE_GOLDENS && output !== golden) {
        console.log('Updating golden file for', path);
        if (output !== null) {
            fs.writeFileSync(path, output, 'utf-8');
        }
        else {
            // The desired golden state is for there to be no output file.
            // Ensure no file exists.
            try {
                fs.unlinkSync(path);
            }
            catch (e) {
            }
        }
    }
    else {
        chai_1.expect(output).to.equal(golden);
    }
}
describe('golden tests', function () {
    testSupport.goldenTests().forEach(function (test) {
        if (RUN_TESTS_MATCHING && !RUN_TESTS_MATCHING.exec(test.name)) {
            it.skip(test.name);
            return;
        }
        var options = {
            // See test_files/jsdoc_types/nevertyped.ts.
            typeBlackListPaths: new Set(['test_files/jsdoc_types/nevertyped.ts'])
        };
        if (/\.untyped\b/.test(test.name)) {
            options.untyped = true;
        }
        it(test.name, function () {
            // Read all the inputs into a map, and create a ts.Program from them.
            var tsSources = new Map();
            for (var _i = 0, _a = test.tsFiles; _i < _a.length; _i++) {
                var tsFile = _a[_i];
                var tsPath = path.join(test.path, tsFile);
                var tsSource = fs.readFileSync(tsPath, 'utf-8');
                tsSources.set(tsPath, tsSource);
            }
            var program = testSupport.createProgram(tsSources);
            {
                var diagnostics = ts.getPreEmitDiagnostics(program);
                if (diagnostics.length) {
                    throw new Error(tsickle.formatDiagnostics(diagnostics));
                }
            }
            // Run TypeScript through the decorator annotator and emit goldens if
            // it changed anything.
            var convertDecoratorsMadeChange = false;
            for (var _b = 0, _c = util_1.toArray(tsSources.keys()); _b < _c.length; _b++) {
                var tsPath = _c[_b];
                // Run TypeScript through the decorator annotator and emit goldens if
                // it changed anything.
                var _d = tsickle.convertDecorators(program.getTypeChecker(), program.getSourceFile(tsPath)), output = _d.output, diagnostics = _d.diagnostics;
                chai_1.expect(diagnostics).to.be.empty;
                if (output !== tsSources.get(tsPath)) {
                    output += decorator_annotator_1.ANNOTATION_SUPPORT_CODE;
                    var decoratedPath = tsPath.replace(/.ts(x)?$/, '.decorated.ts$1');
                    chai_1.expect(decoratedPath).to.not.equal(tsPath);
                    compareAgainstGolden(output, decoratedPath);
                    tsSources.set(tsPath, output);
                    convertDecoratorsMadeChange = true;
                }
            }
            if (convertDecoratorsMadeChange) {
                // A file changed; reload the program on the new output.
                program = testSupport.createProgram(tsSources);
            }
            // Tsickle-annotate all the sources, comparing against goldens, and gather the
            // generated externs and tsickle-processed sources.
            var allExterns = null;
            var tsickleSources = new Map();
            var _loop_1 = function(tsPath) {
                var warnings = [];
                options.logWarning = function (diag) { warnings.push(diag); };
                // Run TypeScript through tsickle and compare against goldens.
                var _e = tsickle.annotate(program, program.getSourceFile(tsPath), options), output = _e.output, externs = _e.externs, diagnostics = _e.diagnostics;
                if (externs)
                    allExterns = externs;
                // If there were any diagnostics, convert them into strings for
                // the golden output.
                var fileOutput = output;
                diagnostics.push.apply(diagnostics, warnings);
                if (diagnostics.length > 0) {
                    // Munge the filenames in the diagnostics so that they don't include
                    // the tsickle checkout path.
                    for (var _f = 0, diagnostics_1 = diagnostics; _f < diagnostics_1.length; _f++) {
                        var diag = diagnostics_1[_f];
                        var fileName = diag.file.fileName;
                        diag.file.fileName = fileName.substr(fileName.indexOf('test_files'));
                    }
                    fileOutput = tsickle.formatDiagnostics(diagnostics) + '\n====\n' + output;
                }
                var tsicklePath = tsPath.replace(/.ts(x)?$/, '.tsickle.ts$1');
                chai_1.expect(tsicklePath).to.not.equal(tsPath);
                compareAgainstGolden(fileOutput, tsicklePath);
                tsickleSources.set(tsPath, output);
            };
            for (var _g = 0, _h = util_1.toArray(tsSources.keys()); _g < _h.length; _g++) {
                var tsPath = _h[_g];
                _loop_1(tsPath);
            }
            compareAgainstGolden(allExterns, test.externsPath);
            // Run tsickled TypeScript through TypeScript compiler
            // and compare against goldens.
            program = testSupport.createProgram(tsickleSources);
            var jsSources = testSupport.emit(program);
            for (var _j = 0, _k = Object.keys(jsSources); _j < _k.length; _j++) {
                var jsPath = _k[_j];
                compareAgainstGolden(jsSources[jsPath], jsPath);
            }
        });
    });
});
//# sourceMappingURL=tsickle_test.js.map