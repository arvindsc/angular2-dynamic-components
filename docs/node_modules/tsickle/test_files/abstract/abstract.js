var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Base = (function () {
    function Base() {
    }
    Base.prototype.bar = function () {
        this.simple();
        this.publicAbstract();
        this.params([]);
        this.noReturnType();
        this.hasReturnType();
    };
    return Base;
}());
var Derived = (function (_super) {
    __extends(Derived, _super);
    // Workaround for https://github.com/google/closure-compiler/issues/1955
    function Derived() {
        _super.call(this);
    }
    Derived.prototype.simple = function () { };
    Derived.prototype.publicAbstract = function () { };
    Derived.prototype.params = function (x) { };
    Derived.prototype.noReturnType = function () { };
    Derived.prototype.hasReturnType = function () { return 3; };
    return Derived;
}(Base));
var x = new Derived();
//# sourceMappingURL=abstract.js.map